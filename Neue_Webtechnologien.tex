\section{Neue Webtechnologien}
Im folgenden Kapitel wird auf neue und zum Teil noch nicht fertig spezifizierte Webtechnologien eingegangen. Die vorgestellten Technologien HTML5, CSS3, PHP7, Web Components, Angular JS, Google Polymer und die Service Worker sollen bei der Entwicklung des Supportportals Verwendung finden.

\subsection{HTML5}\label{HTML5}

\begin{wrapfigure}{r}{4cm}
\centering
\includegraphics[width=4cm]{Bilder/html5.png}
\caption{HTML5 Logo des W3C}
\label{HTML5 Logo des W3C}
\vspace{-40pt}
\end{wrapfigure}

HTML5 ist die aktuelle Fassung, der Hypertext-Auszeichnungssprache HTML, welche vom W3C am 28. Oktober 2014 standardisiert wurde.

Die erste wichtige Neuerung ist die angabe des Dokumententyps, welche nun nur noch \texttt{<!DOCTYPE html>} lautet.

\texttt{section}, \texttt{header} und \texttt{footer} sind nur ein paar Beispiele für die neuen Struktur-Elemente in HTML5, welche es erlauben das Dokument besser zu Strukturieren.

HTML5 bietet aber nicht nur neues. Es erweitert zum Teil auch bestehende Elemente, wie den \texttt{input}-Tag, in welchem nun auch Typdefinitionen wie zum Beispiel Telefonnummern oder E-Mail-Adressen standardisiert sind. Dies ermöglicht dem Browser eine Validierung von gekennzeichneten Tags vorzunehmen ohne auf Java-Skript zurückgreifen zu müssen. 

Da innerhalb der Arbeit nicht auf alle Neuerungen eingegangen werden kann, muss an dieser Stelle auf die HTML5-Definition des W3C\footnote{\url{https://www.w3.org/TR/2014/REC-html5-20141028/}} verwiesen werden. \cite{HTML5W3C} \cite{HTML5Wiki}

\subsection{CSS3}
\ac{CSS} ist eine Designsprache für HTML und ist deshalb eine der Hauptkomponenten der Webentwicklung. Mit Hilfe von \ac{CSS} ist es möglich, einzelne HTML-Elemente oder Gruppen zu stylen.
Seit der ersten Version die 1993 erschien, wird CSS kontinuirlich weiterentwickelt und ist heute auf praktisch jeder Web-Seite im Einsatz.

Auf der Basis von CSS entwickelten sich im Laufe der Jahre immer mehr Frameworks, welche einen Designansatz umsetzten und fertige Klassen für die Verwendung bereitstellen.
Eines der heute am häufigsten anzutreffenden \ac{CSS}-Frameworks ist "`Bootstrap"'.

Innerhalb der PDV Systeme Erfurt wurde beschlossen, ein neues Supportportal im "`Material Design"' aufzubauen. Als "`Material Design"' werden Gestaltungsrichtlinen von Google bezeichnet, welche angeben wie eine Android-Applikation oder eine mobile Web-Seite für Android aussehen sollte.

Das "`Material Design"' ist ein flaches Design und geht von der Metapher aus, dass der Bildschirm Papier ist. Jedes Element soll sich also wie reales Papier verhalten und auch so aussehen.
Obwohl das Design sehr schlicht gehalten ist, so kann mit viel Farbe gearbeitet werden.
\cite{MaterialDesign}

Die nun folgenden Betrachtungen beziehen sich auf die Umsetzung im "`Material Design"'.

\subsubsection{Bootstrap}
Bootstrap ist ein \ac{CSS} Framework, welches von "`Twitter"' entwickelt wird und das unter der "`MIT-Lizenz"' frei erhältlich ist. Durch den modularen Ansatz von Bootstrap ist es sehr leicht möglich, das Framework um eigene Style-Anweisungen zu ergänzen.
\cite{Bootstrap} \cite{WikiBootstrap}

Bootstrap baut auf dem Less-Parser auf. Less ist eine Sprache, die es sich zum Ziel gesetzt hat, das Schreiben von \ac{CSS} möglichst einfach und effizient zu machen. Geschriebener Less-Code muss in \ac{CSS} geparst werden.

Das Bootstrap Framework kann entweder direkt als fertiges \ac{CSS}-Framework oder als Less-Code heruntergeladen werden.

Ein Nachteil von Bootstrap ist, dass es nicht leichtgewichtig ist. Zwar kann es sehr gut erweitert werden, dies macht jedoch das Framework auch schwerfällig. 
Soll zum Beispiel ein Bootstrap-Template für das "`Material Design"' verwendet werden, muss zunächst das "`standard Framework"' eingebunden werden. Ein Template wie "`Material Design for Bootstrap"' überschreibt dann nach der Einbindung zum Teil das standard Framework und ergänzt es um eigene Klassen.
Der Vorteil bei diesem Vorgehen ist klar, dass ein bestehendes Template relativ leicht ausgetauscht werden kann, ohne dass der eigentliche HTML-Code der Web-Seite angepasst werden muss.

Dieser Vorteil wird schnell zum Nachteil, wenn eine Web-Seite erstellt werden soll, bei der es auf Geschwindigkeit ankommt. Durch das Überscheiben des standard Frameworks wird zusätzliche Zeit beim Parsen der Web-Seite benötigt, was vorallem bei älteren PCs auffällt. 
Zusätzlich steigt der Overhead beim Laden einer Seite, da mehr CSS geladen wird, als tatsächlich benötigt wird.

Standardmäßig enthält Bootstrap zum Beispiel keinen Date-Picker, welcher jedoch in einem Supportportal unerlässlich ist. Auch "`Bootstrap Material"' enthält keinen Date-Picker im "`Material Design"'.
Durch den modularen Aufbau von Bootstrap kann natürlich schnell und einfach ein entsprechendendes Template ergänzt werden. Dies bedeutet aber wieder zusätzlichen Overhead.
\cite{MaterialBootstrap}

\subsubsection{MaterializeCSS}\label{MaterializeCSS}
Ein anderes Framework, welches die Design-Richtlinien des "`Material Design"' umsetzt, ist das noch recht neue Framework "`MaterializeCSS"'. 
MaterializeCSS ist ein eigenständiges Framework, welches versucht alle gegebenen Gestaltungsrichtlinen möglichst elegant und performat umzusetzen.

Die MaterializeCSS Quellen sind mit \ac{SASS} geschrieben und müssen vor der Verwendung in CSS komiliert werden. Dieses Vorgehen hat mehrere Vorteile. So ist es zum einen sehr einfach möglich, das Framework um eigene Style-Objekte zu erweitern. Zum anderen hat es den Vorteil, dass die Farbgebung des gesamten Frameworks an einer Stelle zusammen gefasst ist. 
Soll also die Farbgebung geändert werden, so werden in den \ac{SASS}-Quellen des Frameworks die Farben zentral angepasst. Nach einer erneuten Kompilierung stehen dann die Farben im gesamten Framework zur Verfügung.
Ohne dieses Vorgehen müssten die entsprechenden Farben an unzähligen Stellen innerhalb der \ac{CSS}-Datei angepasst werden.
\cite{Materialize}
Ein weitere Vorteil von MaterializeCSS ist, das viele Templates wie ein Date-Picker im "`Material Design"' schon vorhanden sind. Diese Templates können ohne zusätzlichen Overhead verwendet werden.

Auch wenn MaterializeCSS noch sehr jung im Vergleich zu Bootstrap ist und sich zut Zeit noch in der Beta befindet, so ist es doch eine gute Alternative, wenn eine Web-Seite im "`Material Design"' umgesetzt werden soll.
\subsubsection{Vergleich beider CSS-Frameworks}\label{Vergleich beider CSS-Frameworks}
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|p{0.2\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
      \hline
	Vergleichspunkte & Bootstrap Material & MaterializeCSS\\ \hline
	Abhängigkeiten & \vspace{0.1cm}\begin{minipage}[t]{0.3\textwidth}
	                  \begin{itemize}
	                    \item Bootstrap
	                    \item JQuery
	                   \end{itemize} 
	                 \end{minipage}\vspace{0.1cm}
		      & \vspace{0.1cm}\begin{minipage}[t]{0.3\textwidth}
	                  \begin{itemize}
	                   \item JQuery
	                  \end{itemize}
	                \end{minipage}\\ \hline
	Umfang & \vspace{0.1cm}\begin{minipage}{0.3\textwidth}
	          \begin{itemize}
	           \item Standard Layout
	           \item Dialoge
	          \end{itemize}
	         \end{minipage}
	       & \vspace{0.1cm}\begin{minipage}{0.3\textwidth}
	          \begin{itemize}
	           \item Standard Layout
	           \item Dialoge
	           \item Date-Picker
	           \item Card-Views
	           \item Side-Navs
	           \item viele weitere
	          \end{itemize}
	         \end{minipage}\vspace{0.1cm}\\ \hline
	Farbanpassung & über CSS Klassen (17 Farben) & Farben werden in SASS-Quellcode definiert (kein Limit)\\ \hline
	Icons & Verwendung von Material Icons & Verwendung von Material Icons\\ \hline
	Subjektive Geschwindigkeit & teilweise Träge und Langsam & immer schnell und flüssig\\ \hline

    \end{tabular}
  \end{center}
  \caption{Vergleich von Bootstrap Material und MaterializeCSS}
  \label{CSS Vergleich}
\end{table}

In der Tabelle \ref{CSS Vergleich} wurden die beiden Frameworks Bootstrap Material und MaterialiezeCSS gegenübergestellt. Beim Umfang und der Farbanpassung stellt sich ganz Klar heraus, dass MaterialiezeCSS Bootstrap Material weit überlegen ist. Ebenso zeigt die Tabelle, dass MaterialiezeCSS abgesehen von JQuery keine weiteren Abhängigkeiten besitzt.

Zusätzlich lässt sich Subjektiv sagen, dass MaterialiezeCSS schneller und flüssiger arbeitet als Bootstrap Material.

Aus den vorgelegten Gründen wurde innerhalb der PDV Systeme GmbH entschieden für das neue Supportportal MaterialiezeCSS in der Version 0.97.0 (aktuelle Version) zu verwenden. Für die Verwendung innerhalb der PDV Systeme wurde das Framework an die Farben der PDV Systeme angepasst.

\subsection{PHP7}
PHP7 ist die aktuelle Version der Programmiersprache PHP, welche im Dezember 2015 veröffentlicht wurde. PHP7 ist nicht abwärtskompatibel zu alten Versionen und durch eine Neuimplementierung bis zu 30 Prozent schneller als Vorgängerversionen. PHP ist eine Serverseitige-Programmiersprache für die Erstellung von dynamischen Webseiten.\cite{PHPWiki} 

Neue Features in PHP7 sind zum Beispiel die Engine-Exceptions, welche es ermöglichen innerhalb von PHP PHP-Engine-Exceptions abzufangen. \cite{PHPEx}

Da TYPO3 in den aktuellen 8.x-Version auf PHP7 bassiert, muss die Programmiersprache zwingend verwendet werden um TYPO3-Extensions zu erstellen.

\subsection{Web Components}
Web Components sind eine neue Technologie zur Erstellung von Web-Seiten. 
Die Spezifikation des W3C für Web Components sehen, wie der Name sagt, vor Komponenten speziell für Web-Seiten zu erstellen. 
Diese Komponenten können entweder vom Programmierer selbst oder aus Fremdquellen stammen.

Durch die Verwendung soll die Programmierung von Webtechnologien vereinfacht werden. Komponenten kapseln spezielle Elemente wie zum Beispiel Tabellen oder Button mit ihren Funktionen zusammen in ein Element.
Komponenten können also auf einer Vielzahl von Technologien aufbauen. Die Nutzung einer Komponente durch einen Programmierer geht somit auch ohne die Kenntnis aller in der Komponente verwendeten Technologien. 
Ein Programmiere muss sich nicht um die Funktion oder den Aufbau einer Komponente kümmern. Er kann sie einfach benutzen.

Dies bringt zum einen den Vorteil, dass Programmierer sich nicht mehr mit allen Technologien beschäftigen und auskennen müssen. Zum anderen können Komponenten schnell in bestehende und neue Projekte integriert werden. 
Hierdurch kann die Entwicklungszeit einer Web-Seite im Idealfall drastisch gesenkt werden.
\cite{GolemWebComponents}

Web Components bestehen nach der Definition des W3C aus fünf Bestandteilen:
\begin{itemize}
 \item Templates
 \item Decorators
 \item Custom Elements
 \item Shadow DOM
 \item Imports
\end{itemize}

\paragraph{Templates}
sind HTML-Teile, welche beim Rendern einer Web Komponente zum tragen kommen. Sie werden innerhalb der Komponente definiert (siehe Listing \ref{Polymer Element}) und sind von HTML5 standardisiert.

\paragraph{Decorators}
beschreiben das Aussehen eines Templates innerhalb einer Komponente mit Hilfe von CSS. Zum aktuellen Zeitpunkt sind sie jedoch nicht spezifiziert.

\paragraph{Custom Elements}
sind Komponenten, die vom Programmierer selbst erstellt wurden. Sie bilden den Grundstein für wiederverwendbare und eigene Web Components.

\paragraph{Shadow DOM}
ist eine HTML-Struktur, welche vom normalen HTML-DOM aus nicht beeinflusst werden kann (siehe Abschnitt \ref{Shadow DOM}).

\paragraph{Imports}
sind Anweisungen, die dem Browser sagen welche Komponenten er zusätzlich laden muss.
Sie sind essentiell, damit Web Components überhaupt in eine DOM-Struktur eingebunden werden können.
Imports sind wie Templates ebenfalls schon in HTML standardisiert.
\cite{W3CWebComponents}

\subsubsection{Shadow DOM} \label{Shadow DOM}
Damit Komponenten nicht durch CSS-Klassen von der eigentlichen Web-Seite oder sich untereinander beeinflussen, wurde der Shadow DOM erfunden.

Der Shadow DOM ist ein Konstrukt, um Komponenten vor dem eigentlichen HTML-DOM zu verbergen. Dieses Vorgehen ist notwendig, um Komponenten verwenden zu können, denn Komponenten sollen sich werder untereinander Beeinflussen noch sollen sie von der Web-Seite beeinflusst werden.

Komponenten im Shadow DOM werden vor dem eigentlichen HTML-DOM verborgen, wie der Name schon sagt, liegen sie im Schatten. Der Browser rendert also zuerst das HTML-DOM und anschließend den Shadow DOM, ohne das dieser vom eigentlichen DOM beeinflusst wird.
JQuery-Aufrufe auf der Hauptseite zum Beispiel, können sich nicht auf Elemente im Shadow beziehen, da sie diese nicht kennen.

Aktuell, können alle modernen Browser den Shadow DOM umsetzten.
\cite{ShadowDomPolymer}

\subsection{AngularJS} \label{AngularJS}
AngularJS oder kurz Angular ist ein von Google entwickeltes Javascript Framework, welches sich sehr gut für Singe-Page-Web-Sites eignet. 
Angular ist nach dem \ac{MVVM}-Prinzip aufgebaut, welches eine Trennung zwischen Darstellung und Logik bietet und arbeitet Client-seitig.

Die Darstellung wird über HTML abgebildet, welches Angular durch eigene Attribute ergänzt. Die Logik wiederum wird durch Javascript auf Basis von Angular abgebildet.

Angular ist in der Lage das HTML-DOM entsprechend der Befehle der Logik umzubauen, ohne dafür auf JQuery zurückgreifen zu müssen.

Aufgaben, wie das Suchen oder Sortieren einer Tabelle, sind typische Anwendungsbeispiele von Angular.
\cite{AngularBuch}

Die momentan aktuelle Version von Angular ist 1.5.6, welche auch in dieser Arbeit verwendet wird. Zur Zeit wird aber auch der Release von Angular 2.0 vorbereitet, wobei die neue Version nicht abwertskompatibel ist, da sich sehr viel an der Codebasis geändert hat.

Durch das neue Framework soll das ohnehin schon schnelle Framework noch einmal an Geschwindigkeit zunehmen. 

Im folgenden Beispiel der W3C-School wird gezeigt wie Angular eingesetzt werden kann.

\lstinputlisting[language=html, caption=Angular View im HTML-DOM \cite{W3CAngular}, label=Angular View, captionpos=b]{Code/angular_view.html}

Die im Div-Tag zu sehenden Attribute "`ng-app"' und "`ng-controller"' werden von Angular genutzt. "`ng-app"' gibt dabei an, wie die Angular Applikation heißen soll. "`ng-controller"' gibt den Namen des Controllers an, welcher für das HTML-Element zum Einsatz kommen soll.

Innerhalb des Div-Tags, welcher die Applikation darstellt, sind zwei Input-Tags zu sehen, welche das Angular-Attribut "`ng-model"' beinhalten. "`ng-model"' sagt aus, dass diese Elemente zum Datenmodell gehören und welchen Namen sie tragen.

In doppelten geschweiften Klammern werden Modell-Attribute, welche zur Laufzeit von Angular durch die konkreten Werte der Modell-Attribut ersetzt werden, gesetzt.

\lstinputlisting[language=html, caption=Angular ViewModel und Model im HTML-DOM \cite{W3CAngular}, label=Angular ViewModel und Model, captionpos=b]{Code/angular_view-model.html}

Im Listing \ref{Angular ViewModel und Model} ist das ViewModel beziehungsweise das Model des im Listing \ref{Angular View} gezeigten Views zu sehen.

Als erster Schritt wird der zu referenzierende Angular View angegeben und in der Variable "`app"' abgelegt. Daraufhin wird ein Controller innerhalb der Applikation, unter Verwendung des Namens, angelegt.

Innerhalb des Controllers werden dann die Model-Attribute angegeben. Im Beispiel sind das die Werte "`John"' und "`Doe"'. 

Wird nun die entsprechende HTML-Seite im Browser aufgerufen, füllt Angular die beiden Input-Tags mit den Standardwerten und ersetzt auch die Platzhalter in geschweiften Klammern.
Ändert ein Nutzer nun den Inhalt der Input-Tags, so passt Angular automatisch das HTML-Dom an und aktualisiert die Werte innerhalb der geschweiten Klammern.

Das vom Browser geparste Dom enthält keine Angaben darüber, wo sich Platzhalter befinden. Einzig Angular weis, welche Elemente bei einer Änderung angepasst werden müssen.
\cite{W3CAngular}

Durch die neue Version 2.0 von Angular ändert sich die Verwendung und das Paradigma dramatisch. 
Wärend Angular 1 noch auf das \ac{MVVM}-Prinzip setzt, geht Angular 2 den Weg der Web Komponenten. Da bald eine neue Version erscheint, kann zum aktuellen Zeitpunkt noch nicht gesagt, werden wie lange Angular 1 noch unterstützt wird und ob der Einsatz noch sinnvoll ist.

Eine Alternative zu Angular 1 wäre das Java-Script-Framework Aurelia\footnote{\url{www.aurelia.io}} welches einen ähnlichen Umfang wie Angular 1 bietet.

Aus Zeitgründen kann leider an dieser Stelle nicht auf die Verwendung von Aurelia und Angular 2 eingegangen werden.

\subsection{Google Polymer}\label{Google Polymer}
Das Polymer Projekt wird seit 2012 von Google entwickelt und basiert auf dem Web Component-Standard des W3C. Polymer ist eine Library, welche mit Hilfe des Shadow DOM arbeitet. 

Die erste stabile Version von Polymer wurde im März 2016 veröffentlicht und ist stark von AngularJS (siehe Abschnitt \ref{AngularJS}) beeinflusst worden. 

Zur Zeit der Bearbeitung ist Polymer in der Version 1.0 veröffentlicht. Jedoch wird momentan schon an der Version 2.0 gearbeitet, welche auch als Beta verfügbar ist.

In den folgenten Abschnitten wird nun weiter auf Polymer in der Version 1.0 eingegangen.
\cite{PolymerProject}

\subsubsection{Wozu Polymer Elemente}\label{Wozu Polymer Elemente}
Polymer Elemente versuchen den so genannten Boiler-Code unter Zuhilfenahme von Web Komponenten zu vermeiden. Als Boiler-Code wird die Verschmelzung verschiedener Programmiersprachen innerhalb einer Datei oder eines Elements bezeichnet. Boiler-Code ist häufig in Web-Seiten zu finden, was historsch bis heute bedingt ist. Eine weiter gängiger Name für Boiler-Code im Web ist "`DOM Pollution"', was so viel aussagt wie, dass der DOM mit verschiedenen Sprachen verschmutzt ist.

Um ein HTML-Element zu erstellen wird als Grundgerüst HTML verwendet. Zusätzlich enthält das HTML-Element aber auch CSS um das Aussehen zu beeinflussen. Um ein HTML-Element dynamisch oder interaktiv zu gestalten, wird meist zusätzlich auch noch Java-Skript oder AngularJS verwendet. Typischer Weise findet mal alle drei Sprachen in einer HTML-Datei oder in getrennten Dateien. 

Beide Ansätze haben jedoch Nachteile. Bei der Vereinigung verschiedener Sprachen in einer Datei, leidet meist die Übersicht, denn CSS, Java-Skript und zugehöriges HTML muss nicht an festen Positionen sein. So kommt es öfter vor, dass zusammengehörige Elemente innerhalb einer Datei weit auseinander stehen. Hier leidet die Übersicht und Zusammenhänge sind wenn überhaupt oft nur schwer für fremde Programmierer zu erkennen.

Der Ansatz, die verschiedenen Sprachen zu trennen, beseitigt zwar das Durcheinander innerhalb der HTML-Dateien, jedoch entstehen hier wieder neue Probleme. Wenn alle Sprachen strikt in verschiedenen Dateien sind, ist es oft nur schwer nachzuvollziehen, welches Java-Skript zu welchem HTML-Element gehört. Für außenstehende Programmiere ist dies oft eine unlösbare Aufgabe. Nachteilig ist auch, dass immer alle Dateien benötigt werden, um das Gesamtbild verstehen zu können.

\subsubsection{Was macht Polymer aus}
Polymer wiederum geht, im Gegensatz zu den beiden im Abschnitt \ref{Wozu Polymer Elemente} genannten, einen dritten sehr eleganten Ansatz und zwar den der Web Components. Grundsätzlich kommen bei Polymer verschiedene Programmiersprachen und Konzepte wieder zusammen in eine HTML-Datei. 

Der entscheidende Unterschied jedoch ist, das HTML, CSS und Skripte ihre festen Bereiche haben, in denen sie implementiert werden. Dies gestaltet die HTML-Datei des jeweiligen Elements sehr übersichtlich und wurde so in den Web Components vom W3C spezifiziert.

Ein weiterer Vorteil ist, dass in der Web-Seite, in der das Element Verwendung findet nur noch ein einzelner Tag zu sehen ist, der auf das Polymer Element verweist.

Damit der Browser das entsprechende Element mit Hilfe der Polymer Library parsen kann, muss vor der Verwendung das jeweilige Element über den HTML-Link-Tag eingebunden werden.

Das Polymer Projekt bietet eine ganze Reihe fertige Elemente, welche einfach verwendet werden können\footnote{\url{https://elements.polymer-project.org/}}.

Wem diese Elemente mit ihren Funktion noch nicht reichen, kann entweder die bestehenden Elemente erweitern oder neue Elemente erstellen.

\subsubsection{Ein eigenes Polymer Element erstellen}\label{Ein eigenes Polymer Element erstellen}
Um zu zeigen, wie einfach es ist, auf Basis von Polymer Elemente selbst zu erstellen, folgt in den nun kommenden Abschnitten nun ein Beispiel, welches im Kapitel \ref{Zusammenspiel der Technologien} in Typo3 eingebunden wird.

\lstinputlisting[language=html, caption=Beispiel für ein eigenes Polymer-Element, label=Polymer Element, captionpos=b]{Code/polymer_element.html}

Als erstes wird der Polymer-Link hinzugefügt, welcher immer vorhanden sein muss. Danach folgt der Tag "`dom-module"', welcher die genaue Beschreibung des Elements enthält. Im "`template"'-Tag wird das HTML eingefügt, welches das Element beinhaltet. Hierauf kann optional ein "`style"'-Tag folgen, in welchem der Style des HTML-Elements per CSS angegeben wird. 

\paragraph{CSS für ein Element}
Die Definition von CSS hat nur Einfluss auf das jeweilige Template. Elemente außerhalb des Element-DOM werden von dem hier definiertem CSS nicht beeinflusst.

Es ist jedoch umgekehrt möglich, CSS-Klassen zu nutzen, welche im globalen CSS beschrieben sind. Eine erneute Einbindung der CSS-Datei in das Polymer-Element ist nicht notwendig.
Die Verwendung von CSS-Abhängigkeiten in Polymer ist jedoch unschön, da dies ein Element gegebenenfalls auf Web-Seiten beschränkt, welche diese bestimmte CSS-Datei verwenden.
Es ist somit in den meisten Fällen besser keine CSS-Abhängigkeiten in Elementen zu verwenden, vor allem dann wenn diese öffentlich sind.

Im Listing \ref{Polymer Element} wurden CSS-Abhängigkeiten zu MaterializeCSS (Abschnitt \ref{MaterializeCSS}) aufgebaut, eine Begründung hierfür ist im Abschnitt \ref{Vergleich beider CSS-Frameworks} zu finden.

\paragraph{Element-Script}
Der "`script"'-Tag enthält das jeweilige Skript zum Element. Es ist JSON-Notation gehalten und basiert auf Callbacks.

\subparagraph{Die Registrierung} eines Elements steht immer zu Beginn des Skripts. Dieser Teil muss also immer vorhanden sein, damit das jeweilige Element überhaupt dargestellt werden kann (siehe \ref{Polymer Element} Zeile 12 und 13).

% \lstinputlisting[language=html, caption=Polymer-Element Registrierung, label=Element Registrierung, captionpos=b]{Code/element_registration.html}

\subparagraph{Handler} werden in Polymer verwendet, um einzelne Skripte aufzurufen. Innerhalb des Handlers kann ein Java-Skript definiert sein, das ausgeführt wird, wenn der jeweilige Handler getriggert wird (siehe \ref{Polymer Element} Zeilen 14 bis 18).

% \lstinputlisting[language=html, caption=Polymer-Element Handler, label=Element Handler, captionpos=b]{Code/element_handler.html}

Damit ein Handler überhaupt zum Tragen kommt, muss er innerhalb des HTML-Tags, für das das jeweilige Skript sein soll, registriert werden (siehe \ref{Polymer Element} Zeile 7).

% \lstinputlisting[language=html, caption=Polymer-Element Handler Registration, label=Element Handler Registration, captionpos=b]{Code/element_handler_registration.html}

\subparagraph{Attribute,} welche das Polymer-Element haben soll, müssen ebenfalls im Skript definiert werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute, label=Element Attribute, captionpos=b]{Code/element_attributes.html}

Das Attribut "`owner"' wird im Beispiel als String definiert und hat den Standardwert "`Daniel"'.
Jedes im Skript definierte Attribut lässt sich bei Verwendung des Elements wie ein normales XML-Attribut verwenden. Wird bei Verwendung des Elements das "`owner"'-Attribut nicht angegeben, so ist es "`Daniel"'. 
Um den Inhalt des Attributs im Template zu verwenden, muss es in doppelten geschweiften Klammern aufgerufen werden. So kann zum Beispiel ein B-Tag wie folgt geschrieben werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute benutzen, label=Element Attribute benutzen, captionpos=b]{Code/element_attributes_use.html}

\subparagraph{Der Aufruf} dieses Polymer-Elements muss wie im Beispiel umgesetzt werden.

\subsubsection{Zusammenfassung}
Polymer bietet, wie gezeigt wurde, eine echte Alternative zum normalen Web-Seiten-Boiler-Code. Durch die Verwendung von Polymer-Elementen entsteht keine nennenswerte Verzögerung beim Parsen einer Web-Seite durch den Browser.
Es bietet sich daher an, bei Neuentwicklungen auf Polymer zu setzen.

Ob und wie eine Intergration von Polymer in Typo3 möglich ist, wird im Kapitel \ref{Zusammenspiel der Technologien} näher beschrieben.

\subsection{Service Worker}\label{sw}
Als Service Worker werden Skripte bezeichnet, welche vom Browser im Hintergrund ausgeführt werden. So können über Service Worker zum Beispiel Push-Nachrichten empfangen oder Hintergrund-Syncronisationen durchgeführt werden.
Die entsprechenden Skripte werden beim laden einer Webseite mit ausgeliefert und vom Browser ausgeführt. 

Service Worker sind bis heute noch nicht Vollständig standardisiert, bieten aber ein großes Potential, weshalb namenhafte Softwareunternehmen wie Google oder Facebook sie schon seit längeren im großen Stil einsetzen. 
Da Service Worker hoch sensieble Daten wie zum Beispiel Nachrichten transportieren, sind sie nur unter verwenden von HTTPs einsetzbar. \cite{SWGoogle}

Service Worker werden zur Zeit schon den aktuellen Versionen von Chrome, Firefox und Opera unterstützt. Für Safari und Edge, ist die Unterstützung momentan noch in er Entwicklung. \cite{SWSupp1} \cite{SWSupp2}

\subsubsection{Lifecycle eines Service Workers}
Im folgenden Abschnitt wird auf den Lebenszyklus eines Service Workers beschrieben.

\begin{figure}[!ht]
\centering
\includegraphics[width=10cm]{Bilder/sw-lifecycle.png}
\caption{Lifecycle von Service Worker \cite{SWGoogle}}
\label{Lifecycle sw}
\centering
\end{figure}

In Abbildung \ref{Lifecycle sw} ist der Lifecycle von Service Workern dargestellt.
Nach dem Installieren ist der Service Worker aktiv und bereit zum arbeiten. Geht beim Installieren des Workers etwas schief, so gelangt er in einen Fehlerzustand und wird abgeschaltet. Dies kann zum Beispiel passieren, wenn der verwendete Browser keine Service Worker unterstützt.

Nachdem der Worker Aktiviert wurde, geht er in den Leerlauf (Idle) bis er eine Aufgabe zugeteilt bekommt. 
Bekommt der Service Worker eine Aufgabe erledigt er diese und geht danach wieder in den Leerlauf.

Wird der Browser beendet, wird auch die Ausführung des Workers beendet. Sobald der Browser nun erneut gestartet wird, werden auch alle aktivierten Service Worker gestartet.
Nutzer müssen sich also keine gedanken um das starten oder beenden der jeweilien Service Worker machen.

\subsubsection{Entwicklung eines Service Workers}
Zur Entwicklung eines Service Workers sollte der Google Chrome verwendet werden, da dieser die Entwicklung zur Zeit am besten unterstützt. Nur der Chrome erlaubt es momentan einen Service Worker beim einem Seiten-Reload erneut zu installieren. Dies ist wichtige, da nun nicht nach jedem Entwicklungsschritt der komplette Browser-Cache gelöscht werden muss.

Im folgenden wird erläutert wie Push-Nachrichten über einen Service Worker empfangen werden können.

\lstinputlisting[language=JavaScript, caption=Service Worker registrieren, label=sw_reg, captionpos=b]{Code/sw_reg.js}

Im Codebeispiel \ref{sw_reg} wird überprüft, ob der aktuelle Browser Service Worker und Push-Nachrichten unterstützt. Ist dies der Fall, wird der Service Worker welcher sich in der Datei \texttt{sw.js} zu finden ist installiert.

\lstinputlisting[language=JavaScript, caption=Service Worker Hauptfunktion, label=sw_main, captionpos=b]{Code/sw.js}

Innerhalb des Service Worker ist die Codebeispiel \ref{sw_main} gezeigte Funktion dafür verantwortlich Nachrichten zu empfangen und dem Nutzer anzuzeigen.
Im Codebeispiel werden dem Nutzer Standardtexte angezeigt. Es ist aber auch möglich Texte und Nutzdaten in der Nachricht einzubetten und diese im Worker auszulesen.

Das gesamte Beispiel zum empfangen von Push-Nachrichten ist innerhalb der Google Developer Seiten zu finden\footnote{\url{https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/}}.


\section{Zusammenspiel der Technologien}\label{Zusammenspiel der Technologien}
\subsection{Integration von Polymer in Typo3}\label{Typo und Polymer}
Im Abschnitt \ref{Google Polymer} wurde ausführlicher auf die Verwendung und die Erstellung von Polymer-Elementen eingegangen. Nun soll untersucht werden wie sich Polymer möglichst elegant in Typo3 integrieren lässt.

Der beste Weg Polymer-Elemente in Typo3 zu integrieren ist, diese in ViewHelper zu kapseln (siehe Abschnitt \ref{Fluid}). 

Das Ziel ist es also, einen ViewHelper zu erstellen, welcher einen ViewHelper-Tag in einen Polymer-Tag umwandelt.

\begin{wrapfigure}{r}{4cm}
\centering
\includegraphics[width=4cm]{Bilder/Polymer.eps}
\caption{Polymer ViewHelper Hierarchie}
\label{Polymer ViewHelper Hirarchie}
\vspace{-70pt}
\end{wrapfigure}

In Abbildung \ref{Polymer ViewHelper Hirarchie} (rechts) ist die Aufrufhirarchie zu sehen, welche innerhalb des Projektes entwickelt wurde, um Polymer Elemente elegant in Typo3 einzuarbeiten.

Die beim Laden einer Seite aufgerufene "`Action"' eines bestimmten "`Controllers"' wird aufgerufen. Der "`Controller"' stellt alle zum Rendern des Templates benötigte Daten bereit und übergibt sie dem Template.

Das Template wiederum beinhaltet einen für das Polymer Element entwickelten ViewHelper, welcher innerhalb des Templates aufgerufen wird.

Das Fluid-Framework ruft beim Rendern eines Templates den entsprechenden ViewHelper auf. 

Der ViewHelper wiederum gibt den Link zum entsprechenden Polymer Element und den Polymer Tag zurück.

Ist das Template fertig gerendert, so wird es an den aufrufenden Client gesendet.

Der Client wiederum ersetzt das Polymer Element durch HTML.

Am Beispiel des Button-Up Elements (siehe Abschnitt \ref{Ein eigenes Polymer Element erstellen}), wird im folgenden erklärt, wie dieser Prozess im Quellcode umgesetzt wird.
\newpage
\lstinputlisting[language=php, caption=Polymer ViewHelper, label=Polymer ViewHelper, captionpos=b]{Code/viewhelper.php}

Der ViewHelper erbt von der abstrakten Klasse "`AbstractTagBasedViewHelper"'. Dieser ist in der ViewHelper ist anschließend in der Lage, einen HTML-Tag zu verändern.

Mit dem Attribut \texttt{\$tagName} wird definiert wie der neue Tag heißen soll, welcher den ViewHelper-Tag ersetzt. Dieser Tag muss nun so heißen wie das Polymer-Element.

Die Methode \texttt{render} des ViewHelpers gibt den String zurück, der den ViewHelper-Tag ersetzt.

Die "`return"'-Anweisung gibt immer den Link zum entsprechenden Polymer-Element zurück, und den Polymer-Tag.

Der ViewHelper wird nun wie folgt aufgerufen.

\lstinputlisting[language=html, caption=Polymer ViewHelper aufrufen, label=Polymer ViewHelper aufrufen, captionpos=b]{Code/viewhelper_call.php}

Beim ausliefern der Web-Seite ersetzt Typo3 nun den ViewHelper-Tag gegen die folgenden HTML-Elemente

\lstinputlisting[language=html, caption=Polymer ViewHelper Ersetzung, label=Polymer ViewHelper Ersetung, captionpos=b]{Code/viewhelper_after.php}

Wird die Web-Seite nun vom Browser gerendert wird, ersetzt er diesen Polymer-Tag schließlich durch das definierte Polymer-Element.

Durch die Verwendung von ViewHelpern kann jedes beliebige Polymer-Element auch unter Typo3 zum Einsatz kommen. Es ist also sehr elegant möglich Boiler-Code auch in Typo3-Templates und -Partial mit der Hilfe von Polymer zu umgehen.

Durch die Kapselung der Polymer-Elemente in ViewHelpern verhalten sich diese außerdem wie standardmäßige ViewHelper mit Boiler-Code.

Um nun Polymer-Elemente in einem Template zu verwenden, ist kein extra Wissen notwendig, was eine Verwendung so einfach wie möglich macht. Der Programmierer eines Templates muss sich keine Gedanken über Links zu Polymer-Elementen machen und muss sich auch nicht mit Polymer auskennen. Es wird einfach der ViewHelper verwendet und alles andere passiert im Hintergrund.

\subsection{MaterialzeCSS}
Die Integration von MaterializeCSS in Typo3 ist genau so einfach wie die Integration von Bootstrap oder jedem anderem CSS-Frameworks.
Um MaterializeCSS in Typo3 verwenden zu können, muss im Template nur angegeben werden, welche CSS-Dateien Typo3 einbinden soll.

Zusätzlich zu der CSS-Datei benötigt MaterializeCSS noch eine eigene Java-Script-Datei und eine aktuelle Version von JQuery. 
Diese Dateien werden zusammen mit dem CSS im Template definiert.

Außerdem ist es möglich mit MaterialiezeCSS die standard Icons und Schriftarten von Google zu nutzen. Sollen dieses Sachen verwendet werden, so müssen sie nur zusätzlich zum CSS und Java-Script im Template definiert werden.

Im Listing \ref{MaterialieCSS Anbindung} ist ein Typo-Script-Beispiel zu sehen, mit welchem MaterializeCSS in Typo3 integriert wird. Das angegebe Typo-Script wird entweder in der Konfiguration einer Extension angegeben oder es wird direkt in einem Typo3-Template definiert.
\lstinputlisting[caption=MaterialiezeCSS Anbindung, label=MaterialieCSS Anbindung, captionpos=b]{Code/materilaize_anbindung.txt}

\subsection{Nutzer Registrierung und Anmeldung}
TYPO3 liefert eine Extension zur Anmeldung und Registrierung von Fronten Nutzer bereits mit. Diese Extension genügt jedoch nicht den Anforderungen der Use Cases der PDV.

\subsubsection{Use Case Registrierung}
\begin{figure}[!ht]
\centering
\includegraphics[width=10cm]{Bilder/reg_use_case.eps}
\caption{Use Case Nutzerregistrierung}
\label{Use Case Nutzerregistrierung}
\centering
\end{figure}

In Abbildung \ref{Use Case Nutzerregistrierung} ist der Use Case zur Nutzerregistrierung zu sehen. Als erstes registriert sich der Nutzer am Portal. Nach dem Absenden erhält er automatisiert eine Nachricht zur bestätigung der E-Mail-Adresse (Double-Opt-In). Nachdem der Nutzer seine E-Mail-Adresse bestätigt hat, bekommen die Supportmitarbeiter der PDV eine Nachricht, in der sie darüber informiert werden, dass ein neuer Nutzer freigegeben werden möchte. 

Ein Mitarbeiter prüft die Plausibilität der Registrierung und gibt den Nutzer für eine Firma (PDV-Kunde) frei. Anschließend muss der Mitarbeiter noch die Berechtigungen für den Nutzer setzen. Ist der Nutzer von einem Mitarbeiter freigegeben wurden, bekommt er eine Nachricht das er sich nun anmelden kann.

Leider gibt es keine bestehende Extension im \ac{TER} die diesen Use Case auch nur im Ansatz umsetzt, weshalb entschiedende wurde die Registration für Nutzer selbst zu entwickeln.

\subsubsection{Umsetzung der Nutzerregistrierung}

Die Nutzerregistrierung besteht aus einem HTML5-Formular, welches durch den Browser validiert wird (siehe Abschnitt \ref{HTML5}).
Zusätzlich zur Registration im Fronten wurde ein Backend-Modul erstellt, welches es erlaubt PDV Mitarbeitern die Firmen- und Rechtezuordung umzusetzen (siehe Abbildung \ref{Use Case Nutzerregistrierung}. 4 und 5).

Die Firmenrichtlinien der PDV Systeme GmbH erlauben es leider nicht an dieser Stelle den gesamten Controller zur Nutzerregistrierung zu veröffentlichen, weshalb an dieser Stelle kein praktisches Beispiel gegeben werden kann.

\subsubsection{Die Nutzer Anmeldung}
Die TYPO3 eigene Extension \textit{FE\_Login} ist nur schwer zu konfigurieren und bietet keine Möglichkeit den Login in modale Dialoge auszulagern. Aus diesen Gründen wurde entschieden dein Login durch einen eigenen Controller innerhalb der \textit{SupportBase}-Extension zu realisieren.

\begin{figure}[!ht]
\centering
\includegraphics[width=12cm]{Bilder/login.png}
\caption{Login für Frontend-Nutzer}
\label{Login}
\centering
\end{figure}

Hat ein Nutzer das Anmeldeformular \ref{Login} Abbildung abgeschickt, gelangen die Anmeldedaten (Nutzername und Passwort) durch TYPO3 in die Controller-Action \texttt{loginAction}

\lstinputlisting[language=php, caption=loginAction, label=loginAction, captionpos=b]{Code/login.php}

Im Quellcodebeispiel \ref{loginAction} wird der User anhand des Namen aus der Datenbank geholt (Zeile 4). 
Anschliesend wird geprüft, ob das angegebene Passwort mit dem in der Datenbank überein stimmt. Ist dies der Fall, so wird die Nutzer-Session in das \texttt{\$GLOBALS['TSFE']}-Array geschrieben, womit der Nutzer eingeloggt ist. Anschliesend wird der Nutzer zur ursprünglichen Seite von der aus er sich eingeloggt hat umgeleitet.

Wie die modalen Dialoge in das Template gerendert werden, wurde im Abschnitt \ref{Rendering} erklärt.

\subsection{Push-Nachrichten über Service Worker}
Im Abschnitt \ref{sw} wurde beschrieben, wie ein Service Worker erstellt wird um Nutzern Push-Nachrichten anzuzeigen. Nachdem die Clients konfiguriert wurden um Nachrichten zu empfangen, muss natürlich nun auch ein Sender innerhalb der Servers umgesetzt werden. 

Um das senden von Push-Nachrichten zu ermöglichen, gibt es eine Reihe von Librarys für unterschiedliche Programmiersprachen. So auch auch eine für PHP\footnote{\url{https://github.com/web-push-libs/web-push-php}}, welche innerhalb von TYPO3 verwendet werden kann.

Bisher konnte das versenden und empfangen von Nachrichten noch nicht Praktisch umgesetzt werden, da Service Worker wie schon beschrieben nur mittels HTTPs arbeiten. Leider bietet die aktuelle Testumgebung der PDV Systeme keine Möglichkeit eine HTTPs verbindung umzusetzten. Aus diesem Grund, kann die Einbindung der Library "`web-push-php"' nur theoretisch ausgearbeitet werden.

Die Library bietet die Möglichkeit Push-Nachrichten zu erstellen und diese zu versenden. Diese Funktion soll in die \textit{Support Base} Extension integriert werden, da verschiedene Extension in der Lage sein müssen Nachrichten zu versenden.

Es soll eine Wrapperklasse entstehen, welche unter angabe des "`Users"', einer Überschrift, einer Nachricht und einem Link automatisch eine Push-Nachricht erstellt.
Die Wrapperklasse soll anhand des "`Users"' selbstständig die benötigten Verbindungsdaten aus der Datenbank abrufen und die Nachricht versenden.

\begin{figure}[!ht]
\centering
\includegraphics[width=8cm]{Bilder/push_worker.eps}
\caption{Klassendiagramm für PushWorker}
\label{push_uml}
\centering
\end{figure}

\FloatBarrier

In Abbildung \ref{push_uml} ist einmal schematisch dargestellt, wie die Klasse PushWorker aussehen soll. Sie besitzt die öffentliche Methode \texttt{send()}, welche eine Push-Nachricht versendet. Sie wiederum ruft die Methode \texttt{getConnectionData()} auf, welche unter Verwendung der Methode \texttt{getPushinformation()} des \textit{UserRepository} die benötigten Daten für die Push-Nachricht holt. 

Sind anschliesend alle Daten vorhanden, wird die Methode \texttt{sendPush()} innerhalb der Methode \texttt{send()} aufgerufen, welche wiederum unter Verwendung der Klasse \textit{WebPush} aus der \textit{web-push-php}-Library die entsprechende Nachricht generiert und versendet.

\newpage
\section{Zusammenfassung}
Die vorliegende Arbeit befasst sich mit der Entwicklung eines modularen Supportportals für die PDV Systeme GmbH auf Basis eines existierenden \ac{CMS}-Systems. 

Es wurden die vier bekannten \ac{CMS}-Systeme TYPO3 \ac{CMS}, Neos, Joomla und Drupal anhand vorgegebener Kriterien verglichen um eins für die weitere Entwicklung auszuwählen.
Die Entscheidung viel auf TYPO3 \ac{CMS}, welches die Kriterien am besten erfüllt.

TYPO3 \ac{CMS} wird Anschliesend genauer vorgestellt. Hierbei wird der Schwerpunkt auf die Extension-Entwicklung gelegt.

In der Arbeit wird gezeigt, wie es möglich ist modulare Extensions für TYPO3 \ac{CMS} zu erstellen. Hierbei wird darauf eingegangen wie das Datenmodell Extensionübergreifend aufgebaut werden kann. Außerdem ist das Rendering ein wichtiger Punkt. Hier wird gezeigt wie es möglich ist Template-Elemente dynamisch von anderen Extensions zu laden.

Es wird sich damit befasst, wie neue Webtechnologien wie HTML5, CSS3, PHP7, AngularJS, Google Polymer und Service Workern in die aktuelle Version von TYPO3 integriert werden können. Hierfür werden die Technologien zuerst einzeln vorgestellt um später zu zeigen, wie sie sich mit TYPO3 verbinden lassen.
% 
% Zusätzlich wurde anhand einer Neuentwicklung eines Supportportals für die PDV Systeme GmbH gezeigt, wie es möglich ist TYPO3-Extension modular aufzubauen.
% 
% Im Verlauf der Arbeit wurde verschiedene , 
\section{Fazit}
Es ist möglich TYPO3-Extensions modular aufzubauen und neue Webtechnologien zu integrieren. Hierfür wurden in der arbeit viele Beispiele gegeben. 

Neben der Arbeit entstand ein Grundgerüst für ein modulares Supportportal, welches nun nicht nur technisch auf den neusten Stand ist, es lässt sich zudem einfach erweitern.

Durch die gewonnenen Erkentnissen konnte nicht nur die Basis für ein Supportportal geschaffen werden. Es wurde Testweise auch ein weiteres Modul, das Download-Portal implementiert um die genannten Behauptungen zu belegen.

Auf der Basis dieser Arbeit wurden weitere Projektmittel durch die PDV Systeme GmbH gewährt, um das nun begonne Projekt weiterzuführen und das neue Supportportal mit den restlichen Modulen zu vervollständigen.