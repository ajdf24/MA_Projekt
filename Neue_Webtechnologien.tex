\section{Neue Webtechnologien}
\subsection{Google Polymer}\label{Google Polymer}
Polymer Einleitung!
\subsubsection{Wozu Polymer Elemente}\label{Wozu Polymer Elemente}
Polymer Elemente versuchen so genannten Boiler-Code zu vermeiden. Als Boiler-Code wird die Verschmelzung verschiedener Programmiersprachen innerhalb einer Datei oder eines Elements bezeichnet. Boiler-Code ist häufig in Web-Seiten zu finden. 

Um eine HTML-Element zu erstellen wird als Grundgerüst HTML verwendet. Zusätzlich enthält das HTML-Element aber auch CSS um das aussehen zu beeinflussen. Um ein HTML-Element dynamisch oder interaktiv zu gestalten wird meist zusätzlich auch noch Java-Skript oder AngularJS verwendet. Typischer weise findet mal alle drei Sprachen in einer HTML-Datei oder in getrennten Dateien. 

Jedoch haben beide Ansätze Nachteile. Bei der Vereinigung verschiedener Sprachen in einer Datei, leidet meist die Übersicht, denn CSS, Java-Skript und zugehöriges HTML muss nicht an festen Positionen sein. So kommt es öfter vor, dass zusammengehörige Elemente innerhalb einer Datei weit auseinander stehen.

Der Ansatz die verschiedenen Sprachen zu trennen, beseitigt zwar das durcheinander innerhalb der HTML-Dateien, jedoch entstehen hier wieder neue Probleme. Wenn alle Sprachen strikt in verschiedenen Dateien sind, ist es oft nur schwer nachzuvollziehen, welches Java-Skript zu welchem HTML-Element gehört. Für außenstehende Programmiere ist dies oft eine unlösbare Aufgabe.

\subsubsection{Was macht Polymer aus}
Polymer wiederum geht, im Gegensatz zu den beiden im Abschnitt \ref{Wozu Polymer Elemente} genannten, einen dritten sehr eleganten Ansatz. Grundsätzlich kommen bei Polymer verschiedene Programmiersprachen und Konzepte wieder zusammen in eine HTML-Datei. 

Der entscheidende Unterschied jedoch ist, das HTML, CSS und Skripte ihre festen Bereiche haben, in denen sie implementiert werden. Dies gestaltet die HTML-Datei des jeweiligen Elements sehr übersichtlich. 

Ein weiterer Vorteil ist, dass in der Web-Seite, in der das Element Verwendung findet nur noch ein einzelner Tag zu sehen ist, der auf das Polymer Element verweist.

Damit der Polymer das entsprechende Element parsen kann muss vor der Verwendung das jeweilige Element über den HTML-Link-Tag eingebunden werden.

\subsubsection{Ein eigenes Polymer Element erstellen}\label{Ein eigenes Polymer Element erstellen}
Um zu zeigen, wie einfach es ist auf Basis von Polymer Elemente selbst zu erstellen folgt in den nun kommenden Abschnitten nun Beispiel, welches im Kapitel \ref{Zusammenspiel der Technologien} in Typo3 eingebunden wird.

\lstinputlisting[language=html, caption=Beispiel für ein eigenes Polymer-Element, label=Polymer Element, captionpos=b]{Code/polymer_element.html}

Als erstes wird der Polymer-Link hinzugefügt, welcher immer vorhanden sein muss. Danach folgt der Tag "`dom-module"', welcher die genaue Beschreibung des Elements enthält. Im "`template"'-Tag wird das HTML eingefügt, welches das Element beinhaltet. Hierauf kann optional ein "`style"'-Tag folgen, in welchem der Style des HTML-Elements per CSS angegeben wird. 

\paragraph{CSS für ein Element}
Die Definition von CSS hat nur Einfluss auf das jeweilige Template. Elemente außerhalb des Element-DOM werden von dem hier definiertem CSS nicht beeinflusst.

Es ist jedoch umgekehrt möglich, CSS-Klassen zu nutzen, im globalen CSS beschrieben sind. Eine erneute Einbindung der CSS-Datei in das Polymer-Element ist nicht notwendig.
Die Verwendung von CSS-Abhängigkeiten in Polymer ist jedoch unschön, da dies ein Element gegebenen Falls auf Web-Seiten beschränkt, welche diese bestimmte CSS-Datei verwenden.
Es ist somit in den meisten Fällen besser keine CSS-Abhängigkeiten in Elementen zu verwenden, vor allem dann wenn diese öffentlich sind.

Im Listing \ref{Polymer Element} wurden CSS-Abhängigkeiten zu MaterializeCSS (Abschnitt \ref{MaterializeCSS}) aufgebaut, eine Begründung hierfür ist im Kapitel/Abschnitt (?????) zu finden.

\paragraph{Element-Script}
Der "`script"'-Tag enthält das jeweilige Skript zum Element. Es ist JSON-Notation gehalten und basiert auf Callbacks.

\subparagraph{Die Registrierung} eines Elements steht immer zu begin des Skripts. Dieser Teil muss also immer vorhanden sein, damit das jeweilige Element überhaupt dargestellt werden kann.

\lstinputlisting[language=html, caption=Polymer-Element Registrierung, label=Element Registrierung, captionpos=b]{Code/element_registration.html}

\subparagraph{Handler} werden in Polymer verwendet um einzelne Skripte aufzurufen. Innerhalb des Handlers kann ein Java-Skript definiert sein, das ausgeführt wird, wenn der jeweilige Handler getriggert wird.

\lstinputlisting[language=html, caption=Polymer-Element Handler, label=Element Handler, captionpos=b]{Code/element_handler.html}

Damit ein Handler überhaupt zum Tragen kommt, muss er innerhalb des HTML-Tags für das dass jeweilige Skript sein soll registriert werden.

\lstinputlisting[language=html, caption=Polymer-Element Handler Registration, label=Element Handler Registration, captionpos=b]{Code/element_handler_registration.html}

\subparagraph{Attribute,} welche das Polymer-Element haben soll, müssen ebenfalls im Skript definiert werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute, label=Element Attribute, captionpos=b]{Code/element_attributes.html}

Das Attribut "`owner"' wird im Beispiel als String definiert, und hat den Standardwert "`Daniel"'.
Jedes im Skript definiertes Attribut lässt sich bei Verwendung des Elements wie ein normales XML-Attribut verwenden. Wird bei Verwendung des Elements das "`owner"'-Attribut nicht angegeben, so ist es "`Daniel"'. 
Um den Inhalt des Attributs im Template zu verwenden, muss es in doppelten geschweiften Klammern aufgerufen werden. So kann zum Beispiel ein B-Tag wie folgt geschrieben werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute benutzen, label=Element Attribute benutzen, captionpos=b]{Code/element_attributes_use.html}

\subparagraph{Der Aufruf} dieses Polymer-Elements muss wie im Beispiel umgesetzt werden

\subsubsection{Zusammenfassung}
Polymer bietet wie gezeigt wurde eine echte Alternative zum normalen Web-Seiten-Boiler-Code. Durch die Verwendung von Polymer-Elementen entsteht keine nennenswerte Verzögerung beim parsen einer Web-Seite durch den Browser.
Es bietet sich daher an, bei Neuentwicklungen auf Polymer zu setzen.

Ob und wie eine Intergration von Polymer in Typo3 möglich ist, wird im Kapitel \ref{Zusammenspiel der Technologien} näher beschrieben.

\subsection{AngularJS}
\subsection{HTML5}
\subsection{CSS3}
\ac{CSS} ist eine Designsprache für HTML und ist deshalb eine der Hauptkomponenten der Webentwicklung. Mit Hilfe von \ac{CSS} ist es möglich einzelne HTML-Elemente oder Gruppen zu stylen.
Seit der ersten Version die 1993 erschien, wird CSS kontinuirlich weiterentwickelt und ist heute auf praktisch jeder Web-Seite im einsatz.

Auf der Basis von CSS entwickelten sich im laufe der Jahre immer mehr Frameworks, welche einen Designansatz umsetzten und fertige Klassen für die Verwendung bereitstellen.
Eines der heute am häufigsten anzutreffenden \ac{CSS}-Frameworks ist "`Bootstrap"'.

Innerhalb der PDV Systeme Erfurt wurde beschlossen das neue Supportportal im "`Material Design"' aufzubauen. Als "`Material Design"' werden Gestaltungsrichtlinen von Google bezeichnet, welche angeben wie eine Android-Applikation oder eine mobile Web-Seite für Android aussehen sollte.

Das "`Material Design"' ist ein flaches Design, und geht von der Metapher aus, dass der Bildschirm Papier ist. Jedes Element soll sich also wie reales Papier verhalten und auch so aussehen.
Obwohl das Design sehr schlicht gehalten ist, so kann mit viel Farbe gearbeite werden.
\cite{MaterialDesign}

Die nun folgenden Betrachtungen beziehen sich auf die Umsetzung im "`Material Design"'.

\subsubsection{Bootstrap}
Bootstrap ist ein \ac{CSS} Framework, welches von "`Twitter"' entwickelt wird und das unter der "`MIT-Lizenz"' frei erhältlich ist. Durch den modularen Ansatz von Bootstrap ist es sehr leicht möglich das Framework um eigene Style-Anweisungen zu ergänzen.
\cite{Bootstrap} \cite{WikiBootstrap}

Bootstrap baut auf dem Less-Parser auf. Less ist eine Sprache, die es sich zum Ziel gesetzt hat das schreiben von \ac{CSS} möglichst einfach und effizient zu machen. Geschriebender Less-Code muss in \ac{CSS} geparst werden.

Das Bootstrap Framework kann entweder direkt als fertiges \ac{CSS}-Framework oder als Less-Code heruntergeladen werden.

Ein Nachteil von Bootstrap ist, dass es nicht leichtgewichtig ist. Zwar kann es sehr gut erweitert werden, dies macht jedoch das Framework auch Schwerfällig. 
Soll zum Beispiel ein Bootstrap-Template für das "`Material Design"' verwendet werden, muss zunächst das "`standard Framework"' eingebunden werden. Ein Template wie "`Material Design for Bootstrap"' überschreibt dann nach der Einbindung zum Teil das standard Framework und ergänzt es um eigene Klassen.
Der Vorteil bei diesem Vorgehen ist ganz klar, dass ein bestehendes Template relativ leicht ausgetauscht werden kann, ohne dass der eigentliche HTML-Code der Web-Seite angepasst werden muss.

Dieser Vorteil wird schnell zum Nachteil, wenn eine Web-Seite erstellt werden soll bei der es auf Geschwindigkeit ankommt. Durch das überscheiben des standard Frameworks wird zusätzliche Zeit beim parsen der Web-Seite benötigt, was vorallem bei älteren PCs auffällt. 
Zusätzlich steigt der Overhead beim laden einer Seite, da mehr CSS geladen wird, als tatsächlich benötigt wird.

Standardmäßig enthält Bootstrap zum Beispiel keinen Date-Picker, welcher jedoch in einem Supportportal unerlässlich ist. Auch "`Bootstrap Material"' enthält keinen Date-Picker im "`Material Design"'.
Durch den modularen Aufbau von Bootstrap kann natürlich schnell und einfach ein entsprechendendes Template ergänzt werden. Dies bedeutet aber wieder zusätzlichen Overhead.
\cite{MaterialBootstrap}
\subsubsection{MaterializeCSS}\label{MaterializeCSS}
Ein anderes Framework, welches die Design-Richtlinien des "`Material Design"' umsetzt ist das noch recht neue Framework "`MaterializeCSS"'. 
MaterializeCSS ist ein eigenständiges Framework, welches versucht alle gegebenen Gestaltungsrichtlinen möglichst elegant und performat umzusetzen.

Die MaterializeCSS Quellen sind mit \ac{SASS} geschrieben, und müssen vor der Verwendung in CSS komiliert werden. Dieses Vorgehen hat meherer Vorteile. So ist es zum einen sehr einfach möglich das Framework um eigene Style-Objete zu erweitern. Zum anderen hat es den Vorteil, dass die Farbgebung des gesamten Frameworks an einer Stelle zusammen gefasst ist. 
Soll also die Farbgebung geändert werden, so werden in den \ac{SASS}-Quellen des Frameworks die Farben zentral angepasst. Nach einer erneuten kompilierung stehen dann die Farben im gesamten Framework zur Verfügung.
Ohne dieses Vorgehen müssten die entsprechenden Farben an unzähligen Stellen innerhalb der \ac{CSS}-Datei angepasst werden.
\cite{Materialize}
Ein weitere Vorteil von MaterializeCSS ist, das viele Templates wie ein Date-Picker im "`Material Design"' schon vorhanden sind. Diese Templates können ohne zusätzlichen Overhead verwendet werden.

Auch wenn MaterializeCSS noch sehr jung im Vergleich zu Bootstrap ist, so ist es doch eine gute alternative, wenn eine Web-Seite im "`Material Design"' umgesetzt werden soll.
\subsection{PHP7}
\subsection{Google Dart}
\section{Zusammenspiel der Technologien}\label{Zusammenspiel der Technologien}
\subsection{Integration von Polymer in Typo3}
Im Abschnitt \ref{Google Polymer} wurde ausführlicher auf die Verwendung und die Erstellung von Polymer-Elementen eingegangen. Nun soll untersucht werden wie sich Polymer möglichst elegant in Typo3 integrieren lässt.

Der beste Weg Polymer-Elemente in Typo3 zu integrieren ist, diese in ViewHelper zu kapseln (Siehe Kapitel ?????). 

Das Ziel ist es also, einen ViewHelper zu erstellen, welcher einen ViewHelper-Tag in einen Polymer-Tag umwandelt.

\begin{wrapfigure}{r}{4cm}
\centering
\includegraphics[width=4cm]{Bilder/Polymer.eps}
\caption{Polymer ViewHelper Hirarchie}
\label{Polymer ViewHelper Hirarchie}
\vspace{-40pt}
\end{wrapfigure}

In Abbildung \ref{Polymer ViewHelper Hirarchie} (rechts) ist die Aufrufhirarchie zu sehen, welche innerhalb des Projektes entwickelt wurde, um Polymer Elemente elegant in Typo3 einzuarbeiten.

Die beim laden einer Seite aufgerufene "`Action"' eines bestimmten "`Controllers"' wird aufgerufen. Der "`Controller"' stellt alle zum Rendern des Templates benötigte Daten bereit und übergibt sie dem Template.

Das Template wiederum beinhaltet einen für das Polymer Element entwickelten ViewHelper, welcher innerhalb des Templates aufgerufen wird.

Das Fluid-Framework ruft beim Rendern eines Templates den entsprechenden ViewHelper auf. 

Der ViewHelper wiederum gibt den Link zum entsprechenden Polymer Element und den Polymer Tag zurück.

Ist das Template fertig gerendert, so wird es an den aufrufenden Client gesendet.

Der Client wiederum ersetzt das Polymer Element durch HTML.

Am Beispiel des Button-Up Elements (siehe Abschnitt \ref{Ein eigenes Polymer Element erstellen}), wird im folgenden erklärt, wie dieser Prozess im Quellcode umgesetzt wird.
\newpage
\lstinputlisting[language=php, caption=Polymer ViewHelper, label=Polymer ViewHelper, captionpos=b]{Code/viewhelper.php}

Der ViewHelper erbt von der abstrakten Klasse "`AbstractTagBasedViewHelper"'. Dieser ist in der ViewHelper ist anschließend in der Lage, einen HTML-Tag zu verändern.

Mit dem Attribut \$tagname, wird definiert wie der neue Tag heißen soll, welcher den ViewHelper-Tag ersetzt. Dieser Tag muss nun so heißen wie das Polymer-Element.

Die Methode "`render"' des ViewHelpers gibt den String zurück, der den ViewHelper-Tag ersetzt.

Die "`return"'-Anweisung gibt immer den Link zum entsprechenden Polymer-Element zurück, und den Polymer-Tag.

Der ViewHelper wird nun wie folgt aufgerufen.

\lstinputlisting[language=html, caption=Polymer ViewHelper aufrufen, label=Polymer ViewHelper aufrufen, captionpos=b]{Code/viewhelper_call.php}

Beim ausliefern der Web-Seite ersetzt Typo3 nun den ViewHelper-Tag gegen die folgenden HTML-Elemente

\lstinputlisting[language=html, caption=Polymer ViewHelper Ersetzung, label=Polymer ViewHelper Ersetung, captionpos=b]{Code/viewhelper_after.php}

Wird die Web-Seite nun vom Browser gerendert wird, ersetzt er diesen Polymer-Tag schließlich durch das definierte Polymer-Element.

Durch die Verwendung von ViewHelpern, kann jedes beliebige Polymer-Element auch unter Typo3 zum Einsatz kommen. Es ist also sehr elegant möglich Boiler-Code auch in Typo3-Templates und -Partial mit der Hilfe von Polymer zu umgehen.

Durch die Kapselung der Polymer-Elemente in ViewHelpern verhalten sich diese sich außerdem wie standardmäßige ViewHelper mit Boiler-Code.

Um nun Polymer-Elemente in einem Template zu verwenden, ist kein extra Wissen notwendig, was eine Verwendung so einfach wie möglich macht. Der Programmierer eines Templates muss sich keine Gedanken über Links zu Polymer-Elementen machen und muss sich auch nicht mit Polymer auskennen. Es wird einfach der ViewHelper verwendet und alles andere passiert im Hintergrund.

\subsection{MaterialzeCSS}
Die Integration von MaterializeCSS in Typo3 ist genau so einfach, wie die Integration von Bootstrap oder jedem anderem CSS-Frameworks.
Um MaterializeCSS in Typo3 verwenden zu können, muss im Template nur angegeben werden, welche CSS-Dateien Typo3 einbinden soll.

Zusätzlich zu der CSS-Datei benötigt MaterializeCSS noch eine eigene Java-Script-Datei und eine aktuelle Version von JQuery. 
Diese Dateien werden zusammen mit dem CSS im Template definiert.

Außerdem ist es möglich mit MaterialieCSS die standard Icons und Schriftarten von Google zu nutzen. Sollen dieses Sachen verwendet werden, so müssen sie nur zusätzlich zum CSS und Java-Script im Template definiert werden.

Im Listing \ref{MaterialieCSS Anbindung} ist ein Typo-Script-Beispiel zu sehen, mit welchem MaterializeCSS in Typo3 integriert wird. Das angegebe Typo-Script an entweder in der Konfiguration einer Extension angegeben sein oder es wird direkt in einem Typo3-Template definiert.
\lstinputlisting[caption=MaterialieCSS Anbindung, label=MaterialieCSS Anbindung, captionpos=b]{Code/materilaize_anbindung.txt}
\subsection{Nutzer Anmeldung und Registrierung}

\section{Zusammenfassung}
\section{Fazit}