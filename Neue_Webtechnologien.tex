\section{Neue Webtechnologien}
Im folgenden Kapitel wird auf neue und zum Teil noch nicht fertig spezifizierte Webtechnologien eingegangen. Die vorgestellten Technologien HTML5, CSS3, PHP7, Web Components, Angular JS, Google Polymer und die Service Worker sollen bei der Entwicklung des Supportportals Verwendung finden.

\subsection{HTML5}

\begin{wrapfigure}{r}{4cm}
\centering
\includegraphics[width=4cm]{Bilder/html5.png}
\caption{HTML5 Logo des W3C}
\label{HTML5 Logo des W3C}
\vspace{-40pt}
\end{wrapfigure}

HTML5 ist die aktuelle Fassung, der Hypertext-Auszeichnungssprache HTML, welche vom W3C am 28. Oktober 2014 standardisiert wurde.

Die erste wichtige Neuerung ist die angabe des Dokumententyps, welche nun nur noch \texttt{<!DOCTYPE html>} lautet.

\texttt{section}, \texttt{header} und \texttt{footer} sind nur ein paar Beispiele für die neuen Struktur-Elemente in HTML5, welche es erlauben das Dokument besser zu Strukturieren.

HTML5 bietet aber nicht nur neues. Es erweitert zum Teil auch bestehende Elemente, wie den \texttt{input}-Tag, in welchem nun auch Typdefinitionen wie zum Beispiel Telefonnummern oder E-Mail-Adressen standardisiert sind. Dies ermöglicht dem Browser eine Validierung von gekennzeichneten Tags vorzunehmen ohne auf Java-Skript zurückgreifen zu müssen. 

Da innerhalb der Arbeit nicht auf alle Neuerungen eingegangen werden kann, muss an dieser Stelle auf die HTML5-Definition des W3C\footnote{\url{https://www.w3.org/TR/2014/REC-html5-20141028/}} verwiesen werden. \cite{HTML5W3C} \cite{HTML5Wiki}

\subsection{CSS3}
\ac{CSS} ist eine Designsprache für HTML und ist deshalb eine der Hauptkomponenten der Webentwicklung. Mit Hilfe von \ac{CSS} ist es möglich, einzelne HTML-Elemente oder Gruppen zu stylen.
Seit der ersten Version die 1993 erschien, wird CSS kontinuirlich weiterentwickelt und ist heute auf praktisch jeder Web-Seite im Einsatz.

Auf der Basis von CSS entwickelten sich im Laufe der Jahre immer mehr Frameworks, welche einen Designansatz umsetzten und fertige Klassen für die Verwendung bereitstellen.
Eines der heute am häufigsten anzutreffenden \ac{CSS}-Frameworks ist "`Bootstrap"'.

Innerhalb der PDV Systeme Erfurt wurde beschlossen, ein neues Supportportal im "`Material Design"' aufzubauen. Als "`Material Design"' werden Gestaltungsrichtlinen von Google bezeichnet, welche angeben wie eine Android-Applikation oder eine mobile Web-Seite für Android aussehen sollte.

Das "`Material Design"' ist ein flaches Design und geht von der Metapher aus, dass der Bildschirm Papier ist. Jedes Element soll sich also wie reales Papier verhalten und auch so aussehen.
Obwohl das Design sehr schlicht gehalten ist, so kann mit viel Farbe gearbeitet werden.
\cite{MaterialDesign}

Die nun folgenden Betrachtungen beziehen sich auf die Umsetzung im "`Material Design"'.

\subsubsection{Bootstrap}
Bootstrap ist ein \ac{CSS} Framework, welches von "`Twitter"' entwickelt wird und das unter der "`MIT-Lizenz"' frei erhältlich ist. Durch den modularen Ansatz von Bootstrap ist es sehr leicht möglich, das Framework um eigene Style-Anweisungen zu ergänzen.
\cite{Bootstrap} \cite{WikiBootstrap}

Bootstrap baut auf dem Less-Parser auf. Less ist eine Sprache, die es sich zum Ziel gesetzt hat, das Schreiben von \ac{CSS} möglichst einfach und effizient zu machen. Geschriebener Less-Code muss in \ac{CSS} geparst werden.

Das Bootstrap Framework kann entweder direkt als fertiges \ac{CSS}-Framework oder als Less-Code heruntergeladen werden.

Ein Nachteil von Bootstrap ist, dass es nicht leichtgewichtig ist. Zwar kann es sehr gut erweitert werden, dies macht jedoch das Framework auch schwerfällig. 
Soll zum Beispiel ein Bootstrap-Template für das "`Material Design"' verwendet werden, muss zunächst das "`standard Framework"' eingebunden werden. Ein Template wie "`Material Design for Bootstrap"' überschreibt dann nach der Einbindung zum Teil das standard Framework und ergänzt es um eigene Klassen.
Der Vorteil bei diesem Vorgehen ist klar, dass ein bestehendes Template relativ leicht ausgetauscht werden kann, ohne dass der eigentliche HTML-Code der Web-Seite angepasst werden muss.

Dieser Vorteil wird schnell zum Nachteil, wenn eine Web-Seite erstellt werden soll, bei der es auf Geschwindigkeit ankommt. Durch das Überscheiben des standard Frameworks wird zusätzliche Zeit beim Parsen der Web-Seite benötigt, was vorallem bei älteren PCs auffällt. 
Zusätzlich steigt der Overhead beim Laden einer Seite, da mehr CSS geladen wird, als tatsächlich benötigt wird.

Standardmäßig enthält Bootstrap zum Beispiel keinen Date-Picker, welcher jedoch in einem Supportportal unerlässlich ist. Auch "`Bootstrap Material"' enthält keinen Date-Picker im "`Material Design"'.
Durch den modularen Aufbau von Bootstrap kann natürlich schnell und einfach ein entsprechendendes Template ergänzt werden. Dies bedeutet aber wieder zusätzlichen Overhead.
\cite{MaterialBootstrap}

\subsubsection{MaterializeCSS}\label{MaterializeCSS}
Ein anderes Framework, welches die Design-Richtlinien des "`Material Design"' umsetzt, ist das noch recht neue Framework "`MaterializeCSS"'. 
MaterializeCSS ist ein eigenständiges Framework, welches versucht alle gegebenen Gestaltungsrichtlinen möglichst elegant und performat umzusetzen.

Die MaterializeCSS Quellen sind mit \ac{SASS} geschrieben und müssen vor der Verwendung in CSS komiliert werden. Dieses Vorgehen hat mehere Vorteile. So ist es zum einen sehr einfach möglich, das Framework um eigene Style-Objete zu erweitern. Zum anderen hat es den Vorteil, dass die Farbgebung des gesamten Frameworks an einer Stelle zusammen gefasst ist. 
Soll also die Farbgebung geändert werden, so werden in den \ac{SASS}-Quellen des Frameworks die Farben zentral angepasst. Nach einer erneuten Kompilierung stehen dann die Farben im gesamten Framework zur Verfügung.
Ohne dieses Vorgehen müssten die entsprechenden Farben an unzähligen Stellen innerhalb der \ac{CSS}-Datei angepasst werden.
\cite{Materialize}
Ein weitere Vorteil von MaterializeCSS ist, das viele Templates wie ein Date-Picker im "`Material Design"' schon vorhanden sind. Diese Templates können ohne zusätzlichen Overhead verwendet werden.

Auch wenn MaterializeCSS noch sehr jung im Vergleich zu Bootstrap ist und sich zut Zeit noch in der Beta befindet, so ist es doch eine gute Alternative, wenn eine Web-Seite im "`Material Design"' umgesetzt werden soll.
\subsubsection{Vergleich beider CSS-Frameworks}
\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{|p{0.2\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
      \hline
	Vergleichspunkte & Bootstrap Material & MaterializeCSS\\ \hline
	Abhängigkeiten & \begin{minipage}[t]{0.3\textwidth}
	                  \begin{itemize}
	                    \item Bootstrap
	                    \item JQuery
	                   \end{itemize} 
	                 \end{minipage}
		      & \begin{minipage}[t]{0.3\textwidth}
	                  \begin{itemize}
	                   \item JQuery
	                  \end{itemize}
	                \end{minipage}\\ \hline
	Umfang & \begin{minipage}{0.3\textwidth}
	          \begin{itemize}
	           \item Standard Layout
	           \item Dialoge
	          \end{itemize}
	         \end{minipage}
	       & \begin{minipage}{0.3\textwidth}
	          \begin{itemize}
	           \item Standard Layout
	           \item Dialoge
	           \item Date-Picker
	           \item Card-Views
	           \item Side-Navs
	           \item viele weitere
	          \end{itemize}
	         \end{minipage}\\ \hline
	Farbanpassung & über CSS Klassen (17 Farben) & Farben werden in SASS-Quellcode definiert (kein Limit)\\ \hline
	Icons & Verwendung von Material Icons & Verwendung von Material Icons\\ \hline
	Subjektive Geschwindigkeit & teilweise Träge und Langsam & immer schnell und flüssig\\ \hline

    \end{tabular}
  \end{center}
  \caption{Vergleich von Bootstrap Material und MaterializeCSS}
  \label{CSS Vergleich}
\end{table}

In der Tabelle \ref{CSS Vergleich} wurden die beiden Frameworks Bootstrap Material und MaterialiezeCSS gegenübergestellt. Beim Umfang und der Farbanpassung stellt sich ganz Klar heraus, dass MaterialiezeCSS Bootstrap Material weit überlegen ist. Ebenso zeigt die Tabelle, dass MaterialiezeCSS abgesehen von JQuery keine weiteren Abhängigkeiten besitzt.

Zusätzlich lässt sich Subjektiv sagen, dass MaterialiezeCSS schneller und flüssiger arbeitet als Bootstrap Material.

Aus den vorgelegten Gründen wurde innerhalb der PDV Systeme GmbH entschieden für das neue Supportportal MaterialiezeCSS in der Version 0.97.0 (aktuelle Version) zu verwenden. Für die Verwendung innerhalb der PDV Systeme wurde das Framework an die Farben der PDV Systeme angepasst.

\subsection{PHP7}
????? Hier muss noch PHP7 gemacht werden

\subsection{Web Components}
Web Components sind eine neue Technologie zur Erstellung von Web-Seiten. 
Die Spezifikation des W3C für Web Components sehen, wie der Name sagt, vor Komponenten speziell für Web-Seiten zu erstellen. 
Diese Komponenten können entweder vom Programmierer selbst oder aus Fremdquellen stammen.

Durch die Verwendung soll die Programmierung von Webtechnologien vereinfacht werden. Komponenten kapseln spezielle Elemente wie zum Beispiel Tabellen oder Button mit ihren Funktionen zusammen in ein Element.
Komponenten können also auf einer Vielzahl von Technologien aufbauen. Die Nutzung einer Komponente durch einen Programmierer geht somit auch ohne die Kenntnis aller in der Komponente verwendeten Technologien. 
Ein Programmiere muss sich nicht um die Funktion oder den Aufbau einer Komponente kümmern. Er kann sie einfach benutzen.

Dies bringt zum einen den Vorteil, dass Programmierer sich nicht mehr mit allen Technologien beschäftigen und auskennen muss. Zum anderen können Komponenten schnell in bestehende und neue Projekte integriert werden. 
Hierdurch kann die Entwicklungszeit einer Web-Seite im Idealfall drastisch gesenkt werden.
\cite{GolemWebComponents}

Web Components bestehen nach der Definition des W3C aus fünf bestandteilen:
\begin{itemize}
 \item Templates
 \item Decorators
 \item Custom Elements
 \item Shadow DOM
 \item Imports
\end{itemize}

\paragraph{Templates}
sind HTML-Teile, welche beim rendern einer Web Komponente zum tragen kommen. Sie werden innerhalb der Komponente definiert (siehe Listing \ref{Polymer Element}) und sind innerhalb von HTML5 standardisiert.

\paragraph{Decorators}
beschreiben das Aussehen eines Templates innerhalb einer Komponente mit Hilfe von CSS. Zum aktuellen Zeitpunkt sind sie jedoch nicht spezifiziert.

\paragraph{Custom Elements}
sind Komponenten, die vom Programmierer selbst erstellt wurden. Sie bilden den Grundstein für wiederverwendbare und eigene Web Components.

\paragraph{Shadow DOM}
ist eine HTML-Struktur, welche vom normalen HTML-DOM aus nicht beeinflusst werden kann (siehe Abschnitt \ref{Shadow DOM}).

\paragraph{Imports}
sind Anweisungen, die dem Browser sagen welche Komponenten er zusätzlich laden muss.
Sie sind essentiell, damit Web Components überhaupt in eine DOM-Struktur eingebunden werden können.
Imports sind wie Templates ebenfalls schon in HTML standardisiert.
\cite{W3CWebComponents}

\subsubsection{Shadow DOM} \label{Shadow DOM}
Damit Komponenten nicht durch CSS-Klassen von der eigentlichen Web-Seite oder untereinander beeinflussen, wurde der Shadow DOM erfunden.

Der Shadow DOM ist ein konstrukt um Komponenten vor dem eigentlichen HTML-DOM zu verbergen. Dieses vorgehen ist notwendig, um Komponenten verwenden zu können, denn Komponenten sollen sich werder untereinander Beeinflussen noch sollen sie von der Web-Seite beeinflusst werden.

Komponenten im Shadow DOM werden vor dem eigentlich HTML-DOM verborgen, wie der Name schon sagt, liegen sie im Schatten. Der Browser rendert also zuerst das HTML-DOM und anschließend den Shadow DOM, ohne das dieser vom eigentlichen DOM beeinflusst wird.
JQuery aufrufe auf der Hautseite zum Beispiel, können sich nicht auf Elemente im Shadow beziehen, da sie diese nicht kennen.

Zur aktuellen Stunde, können alle modernen Browser den Shadow DOM umsetzten.
\cite{ShadowDomPolymer}

\subsection{AngularJS} \label{AngularJS}
AngularJS oder kurz Angular ist ein von Google entwickeltes Javascript Framework, welches sich sehr gut für Singe-Page-Web-Sites eignet. 
Angular ist nach dem \ac{MVVM}-Prinzip aufgebaut, welches eine Trennung zwischen Darstellung und Logik bietet und arbeitet Client-Seitig.

Die Darstellung wird über HTML abgebildet, welches Angular durch eigene Attribute ergänzt. Die Logik wiederum wird durch Javascript auf Basis von Angular abgebildet.

Angular ist in der Lage das HTML-DOM entsprechend der Befehle der Logik umzubauen ohne dafür auf JQuery zurückgreifen zu müssen.

Aufgaben, wie das Suchen oder Sortieren einer Tabelle sind typische Anwendungsbeispiele von Angular.
\cite{AngularBuch}

Die momentan aktuelle Version von Angular ist 1.5.6, welche auch in dieser Arbeit verwendet wird. Zur Zeit wird aber auch der Release von Angular 2.0 vorbereitet, wobei die neue Version nicht abwertskompatibel ist, da sich sehr viel an der Codebasis geändert hat.

Durch das neue Framework, soll das ohnehin schon schnelle Framework noch einmal an Geschwindigkeit zunehmen. 

Im folgenden Beispiel der W3C-School wird gezeigt wie Angular eingesetzt werden kann.

\lstinputlisting[language=html, caption=Angular View im HTML-DOM \cite{W3CAngular}, label=Angular View, captionpos=b]{Code/angular_view.html}

Die im Div-Tag zu sehenden Attribute "`ng-app"' und "`ng-controller"' werden von Angular genutzt. "`ng-app"' gibt dabei an, wie die Angular Applikation heißen soll. "`ng-controller"' gibt den Namen des Controllers an, welcher für das HTML-Element zum Einsatz kommen soll.

Innerhalb des Div-Tags, welcher die Applikation darstellt, sind zwei Input-Tag zu sehen, welche das Angular-Attribut "`ng-model"' beinhalten. "`ng-model"' sagt aus, dass diese Elemente zum Datenmodell gehören und welchen Namen sie tragen.

In doppelten geschweiften Klammern werden Modell-Attribute, welche zur Laufzeit von Angular durch die konkreten Werte der Modell-Attribut ersetzt werden.

\lstinputlisting[language=html, caption=Angular ViewModel und Model im HTML-DOM \cite{W3CAngular}, label=Angular ViewModel und Model, captionpos=b]{Code/angular_view-model.html}

Im Listing \ref{Angular ViewModel und Model} ist das ViewModel beziehungsweise das Model des im Listing \ref{Angular View} gezeigten Views zu sehen.

Als erster Schritt, wird der zu referenzierende Angular View angegeben und in der Variable "`app"' abgelegt. Daraufhin wird ein Controller innerhalb der Applikation, unter Verwendung des Namens, angelegt.

Innerhalb des Controllers werden dann für die Model-Attribute angegeben. Im Beispiel sind das die Werte "`John"' und "`Doe"'. 

Wird nun die entsprechende HTML-Seite im Browser aufgerufen, füllt Angular die beiden Input-Tags mit den Standardwerten und ersetzt auch die Platzhalter in geschweiften Klammern.
Ändert ein Nutzer nun den Inhalt der Input-Tags, so passt Angular automatisch das HTML-Dom an und aktualisiert die Werte innerhalb der geschweiten Klammern.

Das vom Browser geparste Dom enthält keine Angaben darüber, wo sich Platzhalter befinden. Einzig Angular weis, welche Elemente bei einer Änderung angepasst werden müssen.
\cite{W3CAngular}

Durch die neue Version 2.0 von Angular ändert sich die Verwendung und das Paradigma darmatisch. 
Wärend Angular 1 noch auf das \ac{MVVM}-Prinzip setzt, geht Angular 2 den Weg der Web Komponenten. Da bald eine neue Version erscheint, kann zum aktuellen Zeitpunkt noch nicht gesagt werden wie lange Angular 1 noch unterstützt wird und ob der Einsatz noch sinnvoll ist.

Eine Alternative zu Angular 1 wäre das Java-Script-Framework Aurelia\footnote{\url{www.aurelia.io}} welches einen ähnlichen Umfang wie Angular 1 bietet.

Aus Zeitgründen kann leider an dieser Stelle nicht auf die Verwendung von Aurelia und Angular 2 eingegangen werden.

\subsection{Google Polymer}\label{Google Polymer}
Das Polymer Projekt wird seit 2012 von Google entwickelt und basiert auf dem Web Component-Standard des W3C. Polymer ist eine Library, welche mit Hilfe des Shadow DOM arbeitet. 

Die erste stabile Version von Polymer wurde im März 2016 veröffentlicht und ist stark von AngularJS (siehe Abschnitt \ref{AngularJS}) beeinflusst worden. 

Zur Zeit der Bearbeitung ist Polymer in der Version 1.0 veröffentlicht. Jedoch wird momentan schon an der Version 2.0 gearbeitet, welche auch als Beta verfügbar ist.

In den folgenten Abschnitten wird nun weiter auf Polymer in der Version 1.0 eingegangen.
\cite{PolymerProject}

\subsubsection{Wozu Polymer Elemente}\label{Wozu Polymer Elemente}
Polymer Elemente versuchen sogenannten Boiler-Code unter Zuhilfenahme von Web Komponenten zu vermeiden. Als Boiler-Code wird die Verschmelzung verschiedener Programmiersprachen innerhalb einer Datei oder eines Elements bezeichnet. Boiler-Code ist häufig in Web-Seiten zu finden, was historsch bis heute bedingt ist. Eine weiter gängiger Name für Boiler-Code im Web ist "`DOM Pollution"', was so viel aussagt wie, das der DOM mit verschiedenen Sprachen verschmutzt ist.

Um eine HTML-Element zu erstellen wird als Grundgerüst HTML verwendet. Zusätzlich enthält das HTML-Element aber auch CSS um das aussehen zu beeinflussen. Um ein HTML-Element dynamisch oder interaktiv zu gestalten wird meist zusätzlich auch noch Java-Skript oder AngularJS verwendet. Typischer weise findet mal alle drei Sprachen in einer HTML-Datei oder in getrennten Dateien. 

Beide Ansätze haben jedoch Nachteile. Bei der Vereinigung verschiedener Sprachen in einer Datei, leidet meist die Übersicht, denn CSS, Java-Skript und zugehöriges HTML muss nicht an festen Positionen sein. So kommt es öfter vor, dass zusammengehörige Elemente innerhalb einer Datei weit auseinander stehen. Hier leidet die Übersicht und Zusammenhänge sich wenn überhaupt oft nur schwer für fremde Programmierer zu erkennen.

Der Ansatz die verschiedenen Sprachen zu trennen, beseitigt zwar das durcheinander innerhalb der HTML-Dateien, jedoch entstehen hier wieder neue Probleme. Wenn alle Sprachen strikt in verschiedenen Dateien sind, ist es oft nur schwer nachzuvollziehen, welches Java-Skript zu welchem HTML-Element gehört. Für außenstehende Programmiere ist dies oft eine unlösbare Aufgabe. Nachteilig ist auch, dass immer alle Dateien benötigt werden, um das Gesamtbild verstehen zu können.

\subsubsection{Was macht Polymer aus}
Polymer wiederum geht, im Gegensatz zu den beiden im Abschnitt \ref{Wozu Polymer Elemente} genannten, einen dritten sehr eleganten Ansatz. Den der Web Components. Grundsätzlich kommen bei Polymer verschiedene Programmiersprachen und Konzepte wieder zusammen in eine HTML-Datei. 

Der entscheidende Unterschied jedoch ist, das HTML, CSS und Skripte ihre festen Bereiche haben, in denen sie implementiert werden. Dies gestaltet die HTML-Datei des jeweiligen Elements sehr übersichtlich und wurde so in den Web Components vom W3C spezifiziert.

Ein weiterer Vorteil ist, dass in der Web-Seite, in der das Element Verwendung findet nur noch ein einzelner Tag zu sehen ist, der auf das Polymer Element verweist.

Damit der Browser das entsprechende Element mit Hilfe der Polymer Library parsen kann muss vor der Verwendung das jeweilige Element über den HTML-Link-Tag eingebunden werden.

Das Polymer Projekt bietet eine ganze Reihe fertige Elemente, welche einfach verwendet werden können\footnote{\url{https://elements.polymer-project.org/}}.

Wem diese Elemente mit ihren Funktion noch nicht reichen, kann entweder die bestehenden Elemente erweitern oder neue Elemente erstellen.

\subsubsection{Ein eigenes Polymer Element erstellen}\label{Ein eigenes Polymer Element erstellen}
Um zu zeigen, wie einfach es ist auf Basis von Polymer Elemente selbst zu erstellen folgt in den nun kommenden Abschnitten nun Beispiel, welches im Kapitel \ref{Zusammenspiel der Technologien} in Typo3 eingebunden wird.

\lstinputlisting[language=html, caption=Beispiel für ein eigenes Polymer-Element, label=Polymer Element, captionpos=b]{Code/polymer_element.html}

Als erstes wird der Polymer-Link hinzugefügt, welcher immer vorhanden sein muss. Danach folgt der Tag "`dom-module"', welcher die genaue Beschreibung des Elements enthält. Im "`template"'-Tag wird das HTML eingefügt, welches das Element beinhaltet. Hierauf kann optional ein "`style"'-Tag folgen, in welchem der Style des HTML-Elements per CSS angegeben wird. 

\paragraph{CSS für ein Element}
Die Definition von CSS hat nur Einfluss auf das jeweilige Template. Elemente außerhalb des Element-DOM werden von dem hier definiertem CSS nicht beeinflusst.

Es ist jedoch umgekehrt möglich, CSS-Klassen zu nutzen, im globalen CSS beschrieben sind. Eine erneute Einbindung der CSS-Datei in das Polymer-Element ist nicht notwendig.
Die Verwendung von CSS-Abhängigkeiten in Polymer ist jedoch unschön, da dies ein Element gegebenen Falls auf Web-Seiten beschränkt, welche diese bestimmte CSS-Datei verwenden.
Es ist somit in den meisten Fällen besser keine CSS-Abhängigkeiten in Elementen zu verwenden, vor allem dann wenn diese öffentlich sind.

Im Listing \ref{Polymer Element} wurden CSS-Abhängigkeiten zu MaterializeCSS (Abschnitt \ref{MaterializeCSS}) aufgebaut, eine Begründung hierfür ist im Kapitel/Abschnitt (?????) zu finden.

\paragraph{Element-Script}
Der "`script"'-Tag enthält das jeweilige Skript zum Element. Es ist JSON-Notation gehalten und basiert auf Callbacks.

\subparagraph{Die Registrierung} eines Elements steht immer zu begin des Skripts. Dieser Teil muss also immer vorhanden sein, damit das jeweilige Element überhaupt dargestellt werden kann.

\lstinputlisting[language=html, caption=Polymer-Element Registrierung, label=Element Registrierung, captionpos=b]{Code/element_registration.html}

\subparagraph{Handler} werden in Polymer verwendet um einzelne Skripte aufzurufen. Innerhalb des Handlers kann ein Java-Skript definiert sein, das ausgeführt wird, wenn der jeweilige Handler getriggert wird.

\lstinputlisting[language=html, caption=Polymer-Element Handler, label=Element Handler, captionpos=b]{Code/element_handler.html}

Damit ein Handler überhaupt zum Tragen kommt, muss er innerhalb des HTML-Tags für das dass jeweilige Skript sein soll registriert werden.

\lstinputlisting[language=html, caption=Polymer-Element Handler Registration, label=Element Handler Registration, captionpos=b]{Code/element_handler_registration.html}

\subparagraph{Attribute,} welche das Polymer-Element haben soll, müssen ebenfalls im Skript definiert werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute, label=Element Attribute, captionpos=b]{Code/element_attributes.html}

Das Attribut "`owner"' wird im Beispiel als String definiert, und hat den Standardwert "`Daniel"'.
Jedes im Skript definiertes Attribut lässt sich bei Verwendung des Elements wie ein normales XML-Attribut verwenden. Wird bei Verwendung des Elements das "`owner"'-Attribut nicht angegeben, so ist es "`Daniel"'. 
Um den Inhalt des Attributs im Template zu verwenden, muss es in doppelten geschweiften Klammern aufgerufen werden. So kann zum Beispiel ein B-Tag wie folgt geschrieben werden.

\lstinputlisting[language=html, caption=Polymer-Element Attribute benutzen, label=Element Attribute benutzen, captionpos=b]{Code/element_attributes_use.html}

\subparagraph{Der Aufruf} dieses Polymer-Elements muss wie im Beispiel umgesetzt werden

\subsubsection{Zusammenfassung}
Polymer bietet wie gezeigt wurde eine echte Alternative zum normalen Web-Seiten-Boiler-Code. Durch die Verwendung von Polymer-Elementen entsteht keine nennenswerte Verzögerung beim parsen einer Web-Seite durch den Browser.
Es bietet sich daher an, bei Neuentwicklungen auf Polymer zu setzen.

Ob und wie eine Intergration von Polymer in Typo3 möglich ist, wird im Kapitel \ref{Zusammenspiel der Technologien} näher beschrieben.




\subsection{Service Worker}
\section{Zusammenspiel der Technologien}\label{Zusammenspiel der Technologien}
\subsection{Integration von Polymer in Typo3}\label{Typo und Polymer}
Im Abschnitt \ref{Google Polymer} wurde ausführlicher auf die Verwendung und die Erstellung von Polymer-Elementen eingegangen. Nun soll untersucht werden wie sich Polymer möglichst elegant in Typo3 integrieren lässt.

Der beste Weg Polymer-Elemente in Typo3 zu integrieren ist, diese in ViewHelper zu kapseln (Siehe Kapitel ?????). 

Das Ziel ist es also, einen ViewHelper zu erstellen, welcher einen ViewHelper-Tag in einen Polymer-Tag umwandelt.

\begin{wrapfigure}{r}{4cm}
\centering
\includegraphics[width=4cm]{Bilder/Polymer.eps}
\caption{Polymer ViewHelper Hierarchie}
\label{Polymer ViewHelper Hirarchie}
\vspace{-40pt}
\end{wrapfigure}

In Abbildung \ref{Polymer ViewHelper Hirarchie} (rechts) ist die Aufrufhirarchie zu sehen, welche innerhalb des Projektes entwickelt wurde, um Polymer Elemente elegant in Typo3 einzuarbeiten.

Die beim laden einer Seite aufgerufene "`Action"' eines bestimmten "`Controllers"' wird aufgerufen. Der "`Controller"' stellt alle zum Rendern des Templates benötigte Daten bereit und übergibt sie dem Template.

Das Template wiederum beinhaltet einen für das Polymer Element entwickelten ViewHelper, welcher innerhalb des Templates aufgerufen wird.

Das Fluid-Framework ruft beim Rendern eines Templates den entsprechenden ViewHelper auf. 

Der ViewHelper wiederum gibt den Link zum entsprechenden Polymer Element und den Polymer Tag zurück.

Ist das Template fertig gerendert, so wird es an den aufrufenden Client gesendet.

Der Client wiederum ersetzt das Polymer Element durch HTML.

Am Beispiel des Button-Up Elements (siehe Abschnitt \ref{Ein eigenes Polymer Element erstellen}), wird im folgenden erklärt, wie dieser Prozess im Quellcode umgesetzt wird.
\newpage
\lstinputlisting[language=php, caption=Polymer ViewHelper, label=Polymer ViewHelper, captionpos=b]{Code/viewhelper.php}

Der ViewHelper erbt von der abstrakten Klasse "`AbstractTagBasedViewHelper"'. Dieser ist in der ViewHelper ist anschließend in der Lage, einen HTML-Tag zu verändern.

Mit dem Attribut \$tagname, wird definiert wie der neue Tag heißen soll, welcher den ViewHelper-Tag ersetzt. Dieser Tag muss nun so heißen wie das Polymer-Element.

Die Methode "`render"' des ViewHelpers gibt den String zurück, der den ViewHelper-Tag ersetzt.

Die "`return"'-Anweisung gibt immer den Link zum entsprechenden Polymer-Element zurück, und den Polymer-Tag.

Der ViewHelper wird nun wie folgt aufgerufen.

\lstinputlisting[language=html, caption=Polymer ViewHelper aufrufen, label=Polymer ViewHelper aufrufen, captionpos=b]{Code/viewhelper_call.php}

Beim ausliefern der Web-Seite ersetzt Typo3 nun den ViewHelper-Tag gegen die folgenden HTML-Elemente

\lstinputlisting[language=html, caption=Polymer ViewHelper Ersetzung, label=Polymer ViewHelper Ersetung, captionpos=b]{Code/viewhelper_after.php}

Wird die Web-Seite nun vom Browser gerendert wird, ersetzt er diesen Polymer-Tag schließlich durch das definierte Polymer-Element.

Durch die Verwendung von ViewHelpern, kann jedes beliebige Polymer-Element auch unter Typo3 zum Einsatz kommen. Es ist also sehr elegant möglich Boiler-Code auch in Typo3-Templates und -Partial mit der Hilfe von Polymer zu umgehen.

Durch die Kapselung der Polymer-Elemente in ViewHelpern verhalten sich diese sich außerdem wie standardmäßige ViewHelper mit Boiler-Code.

Um nun Polymer-Elemente in einem Template zu verwenden, ist kein extra Wissen notwendig, was eine Verwendung so einfach wie möglich macht. Der Programmierer eines Templates muss sich keine Gedanken über Links zu Polymer-Elementen machen und muss sich auch nicht mit Polymer auskennen. Es wird einfach der ViewHelper verwendet und alles andere passiert im Hintergrund.

\subsection{MaterialzeCSS}
Die Integration von MaterializeCSS in Typo3 ist genau so einfach, wie die Integration von Bootstrap oder jedem anderem CSS-Frameworks.
Um MaterializeCSS in Typo3 verwenden zu können, muss im Template nur angegeben werden, welche CSS-Dateien Typo3 einbinden soll.

Zusätzlich zu der CSS-Datei benötigt MaterializeCSS noch eine eigene Java-Script-Datei und eine aktuelle Version von JQuery. 
Diese Dateien werden zusammen mit dem CSS im Template definiert.

Außerdem ist es möglich mit MaterialiezeCSS die standard Icons und Schriftarten von Google zu nutzen. Sollen dieses Sachen verwendet werden, so müssen sie nur zusätzlich zum CSS und Java-Script im Template definiert werden.

Im Listing \ref{MaterialieCSS Anbindung} ist ein Typo-Script-Beispiel zu sehen, mit welchem MaterializeCSS in Typo3 integriert wird. Das angegebe Typo-Script an entweder in der Konfiguration einer Extension angegeben sein oder es wird direkt in einem Typo3-Template definiert.
\lstinputlisting[caption=MaterialiezeCSS Anbindung, label=MaterialieCSS Anbindung, captionpos=b]{Code/materilaize_anbindung.txt}
\subsection{Nutzer Anmeldung und Registrierung}

\section{Zusammenfassung}
\section{Fazit}